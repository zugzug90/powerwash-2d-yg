require "lib.game_config"
require "lib.game_constants"
require "lib.game_rules_engine"
require "lib.player_data_holder"
require "lib.game_integrations_sdk_holder"

local camera = require "orthographic.camera"

require("lib.player_data_holder")

local player_improvements_manager = require "lib.player_improvements_manager"

go.property("debug", true)


local function screen_to_world(camera, x, y, z, camera_id)
    return camera.screen_to_world(camera_id, vmath.vector3(x, y, z))
end

local function disable_debug_indicators_if_needed(self)
	msg.post("#debug_sprite", "disable")
	if DEBUG == true and DEBUG_SHOW_DEBUG_INDICATOR == true then
		msg.post("#debug_sprite", "enable")
	end
end

local function update_gui_elements(weapon_stats)
	msg.post(GUI_ID, MSG_UPDATE_WEAPON_STATS_RAW, weapon_stats)
end

local function move_camera_to_position(camera_id, position)
	go.set_position(position, camera_id)
end

local function unblock_sound_manager_if_needed(self)
	msg.post(SOUND_MANAGER_ID, MSG_SOUND_UNBLOCK_PLAYING_RAW)
	PLAYER_DATA.touches_count = PLAYER_DATA.touches_count + 1
end

local function vibrate_weapon(self)
	go.animate(".", "scale", go.PLAYBACK_LOOP_PINGPONG, 0.95, go.EASING_LINEAR, 0.16, 0, function() end)

	local pos = vmath.vector3(self.original_pos.x, self.original_pos.y - 5, self.original_pos.z)
	go.animate(".", "position", go.PLAYBACK_LOOP_PINGPONG, pos, go.EASING_LINEAR, 0.16, 0, function() end)

end

local function stop_vibrate_weapon(self)
	go.cancel_animations(".", "scale")
	go.cancel_animations(".", "position")

	go.set_scale(1, ".")
	go.set_position(self.original_pos, ".")
end

local function reset_weapon_tint(self)
	go.set("#sprite", "tint.x", 1)
	go.set("#sprite", "tint.y", 1)
	go.set("#sprite", "tint.z", 1)

end

local function stop_powerup_vfx_if_needed(self)
	if self.powerup_vfx_stopped then 
		return
	end
	if PLAYER_DATA.player_improvements.laser_power_level_multiplier == 1 or PLAYER_DATA.weapon_stats.laser_energy <= 0 then
		reset_weapon_tint(self)
		sprite.play_flipbook(LASER_BEAM_ID .. "#sprite", "laser_beam", function(self, message_id, message, sender)
		end)
		stop_vibrate_weapon(self)
		self.powerup_vfx_stopped = true
	end
end

local function switch_laser_animation(self)
	if PLAYER_DATA.player_improvements.laser_power_level_multiplier == 1 or PLAYER_DATA.weapon_stats.laser_energy <= 0 then
		reset_weapon_tint(self)
		sprite.play_flipbook(LASER_BEAM_ID .. "#sprite", "laser_beam", function(self, message_id, message, sender)
		end)
		stop_vibrate_weapon(self)

	elseif PLAYER_DATA.player_improvements.laser_power_level_multiplier > 1 then

		go.set("#sprite", "tint.x", 0.8)
		go.set("#sprite", "tint.y", 0.1)
		go.set("#sprite", "tint.z", 0.1)

		print('sprite.play_flipbook(LASER_BEAM_ID .. "#sprite", "laser_beam_powerup_1", function(self, message_id, message, sender)')
		sprite.play_flipbook(LASER_BEAM_ID .. "#sprite", "laser_beam_powerup_1", function(self, message_id, message, sender)
		end)

		vibrate_weapon(self)
	end
end

local function switch_skin(self)
	self.current_skin = self.current_skin + 1
	if self.current_skin > #self.skins then
		self.current_skin = 1
	end
end

local function shake_camera(camera_id)
	local shake_x_amplitude = 0.1
	local one_slide_duration = 0.08
	local slide_length = 100
	local original_pos = go.get_position(camera_id)
	local new_pos_a = vmath.vector3(original_pos.x + slide_length * shake_x_amplitude, original_pos.y, original_pos.z)
	local new_pos_b = vmath.vector3(original_pos.x - slide_length * shake_x_amplitude, original_pos.y, original_pos.z)

	go.animate(camera_id, "position", go.PLAYBACK_ONCE_FORWARD, new_pos_a, go.EASING_LINEAR, one_slide_duration, 0, function()
		go.animate(camera_id, "position", go.PLAYBACK_ONCE_FORWARD, new_pos_b, go.EASING_LINEAR, one_slide_duration, 0, function()
			go.animate(camera_id, "position", go.PLAYBACK_ONCE_FORWARD, new_pos_a, go.EASING_LINEAR, one_slide_duration, 0, function()
				go.animate(camera_id, "position", go.PLAYBACK_ONCE_FORWARD, new_pos_b, go.EASING_LINEAR, one_slide_duration, 0, function()
					go.animate(camera_id, "position", go.PLAYBACK_ONCE_FORWARD, new_pos_a, go.EASING_LINEAR, one_slide_duration, 0, function()
						go.animate(camera_id, "position", go.PLAYBACK_ONCE_FORWARD, new_pos_b, go.EASING_LINEAR, one_slide_duration, 0, function()
							go.animate(camera_id, "position", go.PLAYBACK_ONCE_FORWARD, original_pos, go.EASING_LINEAR, one_slide_duration, 0, function()

							end)
						end)
					end)
				end)
			end)
		end)
	end)
end

local function animate_smoke(self)
	msg.post("#sprite", "disable")
	msg.post("#smoke_effect_sprite", "enable")
	sprite.play_flipbook("#smoke_effect_sprite", "smoke_animation", function(self, message_id, message, sender)
		msg.post("#smoke_effect_sprite", "disable")
	end)
end

local function erase_line(self)
	msg.post(LASER_BEAM_ID .. "#sprite", "disable")
	go.set_position(LASER_BEAM_POSITION, LASER_BEAM_ID)
	go.set_scale(vmath.vector3(1, 1, 1), LASER_BEAM_ID)
	go.set_rotation(vmath.quat_rotation_z(math.pi / 2), LASER_BEAM_ID)
end

local function draw_line(self, from, to)
	--local offset =

	erase_line(self)

	local corrected_to = vmath.vector3(to.x, to.y, to.z)
	--corrected_to.x = corrected_to.x + 50

	msg.post(LASER_BEAM_ID .. "#sprite", "enable")

	--print('PLAYER_DATA.player_improvements.laser_power_level_multiplier', PLAYER_DATA.player_improvements.laser_power_level_multiplier)

	local line_length = math.sqrt((from.x - corrected_to.x) * (from.x - corrected_to.x) + (from.y - corrected_to.y) * (from.y - corrected_to.y))

	local additional_scale_delta = 0


	local scale_levels = {
		[2] = 0.5,
		[3] = 1,
		[4] = 1.2,
		[5] = 1.5,
		[6] = 1.6,
		[7] = 1.75
	}

	if PLAYER_DATA.player_improvements.laser_power_level > 1 then
		--additional_scale_delta = math.max(0.5, 1 * PLAYER_DATA.player_improvements.laser_power_level / 8)
		if scale_levels[PLAYER_DATA.player_improvements.laser_power_level] then
			additional_scale_delta = scale_levels[PLAYER_DATA.player_improvements.laser_power_level]
		else
			additional_scale_delta = scale_levels[7]
		end
	end

	--additional_scale_delta = 0

	go.set_scale(vmath.vector3(1 + additional_scale_delta, line_length, 1), LASER_BEAM_ID)

	local beam_go_pos = go.get_position(LASER_BEAM_ID)

	local beam_go_pos_angle = math.atan2(self.to.y - beam_go_pos.y, self.to.x -
			beam_go_pos.x)

	beam_go_pos.x = beam_go_pos.x + (line_length / 2) * math.cos(beam_go_pos_angle)
	beam_go_pos.y = beam_go_pos.y + (line_length / 2) * math.sin(beam_go_pos_angle)

	beam_go_pos.z = LASER_Z_COORD
	go.set_position(beam_go_pos, LASER_BEAM_ID)

		go.set_rotation(vmath.quat_rotation_z(beam_go_pos_angle + math.pi / 2), LASER_BEAM_ID)

	--msg.post("@render:", "draw_line", { start_point = from * 1.1, end_point = to * 1.1, color = vmath.vector4(1,0,0,1) })
end

local function signal_stop_hitting_to_tile(self)
	pcall(function()
		if go.exists(self.current_tile_go_id) then
			msg.post(self.current_tile_go_id, MSG_STOP_HIT_CLEANABLE_DIRT_SPOT)
		end

		self.current_tile_go_id = nil
	end)
end


local function move_camera_to_fit_tiles_image_if_needed(self)
	if CAMERA_MOVEMENT_TO_FIT_OBJECT_MODE_ENABLED ~= true then
		return
	end
	local camera_new_position = vmath.vector3(self.camera_original_pos.x, self.camera_original_pos.y, self.camera_original_pos.z)

	if self.current_touch_pos.y >= GAME_SCREEN_H / 2 then
		camera_new_position.y = self.camera_original_pos.y + (self.current_touch_pos.y / GAME_SCREEN_H) * 200
	else
		--camera_new_position.y = self.camera_original_pos.y
	end


	local distance_horizontal = self.current_touch_pos.x

	print('distance_horizontal', distance_horizontal)

	if distance_horizontal >= GAME_SCREEN_W / 2 then
		camera_new_position.x = self.camera_original_pos.x + (distance_horizontal / GAME_SCREEN_W) * 100
	else
		--camera_new_position.x = self.camera_original_pos.x
	end

	move_camera_to_position(CAMERA_ID, camera_new_position)
end

function fixed_update(self, dt)

	if self.current_touch_pos then
		--move_camera_to_fit_tiles_image_if_needed(self)
	end

	if self.laser_on == true then

		--[[if PLAYER_DATA.player_improvements.laser_power_level_multiplier <= 1 then
			stop_vibrate_weapon(self)
			reset_weapon_tint(self)
			switch_laser_animation(self)
		end]]

		local from = go.get_position()
		local to = self.to


		--to.y = self.to.y - 150


		local world_pos = screen_to_world(camera, to.x, to.y, 0)
		--self.current_touch_pos.x = world_pos.x
		--self.current_touch_pos.y = world_pos.y

		local result = physics.raycast(from, to, { hash("tile") }) -- <4>
		

		if result then

			if self.current_tile_go_id and self.current_tile_go_id ~= result.id then
				signal_stop_hitting_to_tile(self)
			end
			self.current_tile_go_id = result.id
			draw_line(self, from, result.position) -- <5>

			pcall(function()
				if go.exists(self.current_tile_go_id) then
					msg.post(self.current_tile_go_id, MSG_HIT_CLEANABLE_DIRT_SPOT)
				end
			end)
		else
			pcall(function()

				if go.exists(self.current_tile_go_id) then
					msg.post(self.current_tile_go_id, MSG_STOP_HIT_CLEANABLE_DIRT_SPOT)
				end
			end)
			self.current_tile_go_id = nil

			draw_line(self, from, to) -- <6>
		end
	else
		msg.post(SOUND_MANAGER_ID, MSG_SOUND_STOP_RAW, {sound_id = "powerwash_sound"})
	end


end

local function is_player_in_game_powerup_mode(self)
	return PLAYER_DATA.game_powerup_mode
end

local function handle_game_over_if_needed(self)
	if PLAYER_DATA.weapon_stats.laser_energy <= 0 and is_player_in_game_powerup_mode(self) == false then
		msg.post(SOUND_MANAGER_ID, MSG_SOUND_STOP_RAW, {sound_id = "powerwash_sound"})
		switch_laser_animation(self)
		PLAYER_DATA.weapon_stats.laser_energy = 0
		msg.post(SOUND_MANAGER_ID, MSG_SOUND_PLAY_RAW, {sound_id = "power_down"})
		msg.post(LEVEL_GENERATOR_ID, MSG_RESET_DIRT_SPOTS)
		GAME_RULES_ENGINE.on_game_over()

		signal_stop_hitting_to_tile(self)
		self.current_tile_go_id = nil
	end
end

local function update_money_stats_with_custom_increment(self, money_increment)
	PLAYER_DATA.weapon_stats.money_earned = PLAYER_DATA.weapon_stats.money_earned + money_increment
	update_gui_elements({money_earned = PLAYER_DATA.weapon_stats.money_earned})
end

local function update_money_stats(self)
	PLAYER_DATA.weapon_stats.money_earned = PLAYER_DATA.weapon_stats.money_earned + TILE_CRUSHER_MONEY_INCREMENT_SIZE * player_improvements_manager.progression.money_per_tile_earning_levels[PLAYER_DATA.player_improvements.money_per_tile_earning_level]
	update_gui_elements({money_earned = PLAYER_DATA.weapon_stats.money_earned})
end

local function restart_game(self)
	PLAYER_DATA.game_powerup_mode = false
	self.laser_on = false
	self.laser_disabled = false

	PLAYER_DATA.weapon_stats.money = 0
	PLAYER_DATA.weapon_stats.laser_energy = player_improvements_manager.progression.battery_capacity_levels[PLAYER_DATA.player_improvements.battery_capacity_level]

	self.to = vmath.vector3()

	update_gui_elements(PLAYER_DATA.weapon_stats)

	stop_vibrate_weapon(self)
	reset_weapon_tint(self)
	msg.post(LEVEL_GENERATOR_ID, MSG_RESET_DIRT_SPOTS)

	erase_line(self)
end

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post(CAMERA_ID, "acquire_camera_focus")
	go.set_position(PLAYER_POSITION)
	self.original_pos = go.get_position()
	self.skins = {1, 2, 3}
	self.current_skin = 1
	self.laser_disabled = false
	self.camera_original_pos = go.get_position(CAMERA_ID)
	self.debug_mode_activated = false
	self.debug_secret_key_pressed_count = 0

	go.set_position(LASER_BEAM_POSITION, LASER_BEAM_ID)
	go.set_position(CAMERA_POSITION, CAMERA_ID)
	camera.set_zoom(nil, 1)

	go.set_rotation(vmath.quat_rotation_z(0))

	disable_debug_indicators_if_needed(self)

	restart_game(self)
end

function on_message(self, message_id, message, sender)
	if message_id == MSG_RESTART_GAME or message_id == MSG_NEW_GAME then
		print('[player_controller] restart_game(self)')
		restart_game(self)
	elseif message_id == MSG_DISABLE_LASER then
		self.laser_disabled = true
		self.laser_on = false
		erase_line(self)
		switch_laser_animation(self)
		stop_vibrate_weapon(self)
		reset_weapon_tint(self)
		msg.post(SOUND_MANAGER_ID, MSG_SOUND_STOP, {sound_id = 'powerwash_sound'})
	elseif message_id == MSG_DIRT_SPOT_DESTROYED then
		update_money_stats(self)
	elseif message_id == MSG_INCREMENT_MONEY_EARNED then
		update_money_stats_with_custom_increment(self, message.increment or 0)
	elseif message_id == MSG_UPDATE_GAME_FEATURE_STATS then
		if message.feature_stopped == true then
			switch_laser_animation(self)
		elseif message.feature_started == true then
			switch_laser_animation(self)
		end
	end
end

-- PLAYER_DATA.weapon_stats.money = PLAYER_DATA.weapon_stats.money + player_improvements_manager.progression.money_per_tile_earning_levels[PLAYER_DATA.player_improvements.money_per_tile_earning_level]

local function update_weapon_stats(self)
	PLAYER_DATA.weapon_stats.laser_energy = PLAYER_DATA.weapon_stats.laser_energy - TILE_CRUSHER_ENERGY_DECREMENT_SIZE * PLAYER_DATA.player_improvements.laser_power_level * PLAYER_DATA.laser_power_decrease_multiplier * PLAYER_DATA.player_improvements.laser_power_level_multiplier

	handle_game_over_if_needed(self)
	update_gui_elements({laser_energy = PLAYER_DATA.weapon_stats.laser_energy})
end

local function trigger_next_level(self)
	PLAYER_DATA.game_powerup_mode = false
	PLAYER_DATA.current_level = PLAYER_DATA.current_level + 1
	GAME_RULES_ENGINE.on_next_level()
end

local function trigger_previous_level(self)
	PLAYER_DATA.game_powerup_mode = false
	PLAYER_DATA.current_level = math.max(1, PLAYER_DATA.current_level - 1)
	GAME_RULES_ENGINE.on_next_level()
end

local function handle_debug_mode_activation_if_needed(action, action_id, self)
	if DEBUG == false then
		if action_id == hash("key_d") and action.released and self.debug_mode_activated == false then
			self.debug_secret_key_pressed_count = self.debug_secret_key_pressed_count + 1
			if self.debug_secret_key_pressed_count >= 5 then
				self.debug_mode_activated = true
				DEBUG = true
				msg.post(GUI_ID, MSG_DEBUG_MODE_ACTIVATED)
			end
		end
	end
end

function on_input(self, action_id, action)


	if action_id == hash("touch") then -- <3>
		if self.laser_disabled == true then
			return
		end

		if action.x and action.y then
			self.current_touch_pos = vmath.vector3(action.x, action.y, go.get_position().z)

			local world_pos = screen_to_world(camera, action.x, action.y, 0)
			--self.current_touch_pos.x = world_pos.x
			--self.current_touch_pos.y = world_pos.y
		end

		if action.pressed then
			self.powerup_vfx_stopped = false
			unblock_sound_manager_if_needed(self)

			if self.laser_on == false then
				switch_laser_animation(self)
				msg.post(OBJ_TUTORIAL_HINT_ID, MSG_TUTORIAL_HIDE_HINT_RAW)
				msg.post(SOUND_MANAGER_ID, MSG_SOUND_PLAY, {sound_id = 'powerwash_sound'})
			end
			self.laser_on = true

		elseif action.released then
			self.laser_on = false
			self.current_touch_pos.x = 0
			self.current_touch_pos.y = 0

			stop_vibrate_weapon(self)
			reset_weapon_tint(self)

			if PLAYER_DATA.music_started == false then
				PLAYER_DATA.music_started = true
			end

			signal_stop_hitting_to_tile(self)
			erase_line(self)
			msg.post(SOUND_MANAGER_ID, MSG_SOUND_STOP, {sound_id = 'powerwash_sound'})

		end
		if self.laser_on == true then
			if PLAYER_DATA.weapon_stats.laser_energy > 0 then

				local world_pos = screen_to_world(camera, action.x, action.y, 0)

				self.to.x = world_pos.x
				self.to.y = world_pos.y

				


				local gun_pos = go.get_position()
				self.angle = math.atan2(world_pos.y - gun_pos.y, world_pos.x - gun_pos.x)
				go.set_rotation(vmath.quat_rotation_z(self.angle))

				local beam_length = GAME_SCREEN_W * 2
				self.to.x = gun_pos.x + beam_length * math.cos(self.angle)
				self.to.y = gun_pos.y + beam_length * math.sin(self.angle)

				
				--self.to.x = world_pos.x
				--self.to.y = world_pos.y

				update_weapon_stats(self)
			else
				self.laser_on = false
				erase_line(self)
				-- TODO: show some warn label: no energy?
			end

		end

	end

	handle_debug_mode_activation_if_needed(action, action_id, self)

	if DEBUG == true then
		if self.can_restart_game == true and action_id == hash("key_f9") and action.released then
			self.can_restart_game = false
			--timer.delay(0.3, false, function()
			GAME_RULES_ENGINE.on_restart_game()
			timer.delay(1, false, function()
					self.can_restart_game = true
				end)
			--end)
		end
		if action_id == hash("key_f7") and action.released then
		end

		if (action_id == hash("key_p") or action_id == hash("key_n")) and action.released then
			print('action_id : : ', action_id)
			if action_id == hash("key_n") then
				trigger_next_level(self)
			else
				trigger_previous_level(self)
			end
		end

		if action_id == hash("key_f3") or action_id == hash("key_s") and action.released then
			switch_skin(self)
			GAME_RULES_ENGINE.on_restart_game()
			return
		end
	end
	--[[if action_id == hash("touch") then
		if action.released then
			unblock_sound_manager_if_needed(self)
		end
	end]]
end